using System.Collections.Generic;
using UnityEngine;

public class MazeGenerator : MonoBehaviour
{
    [Header("Maze Settings")]
    public int width = 10;
    public int height = 10;

    [Header("Prefabs")]
    public GameObject wallPrefab;
    public GameObject floorPrefab;

    [Header("Scaling")]
    public Vector3 wallScale = new Vector3(1, 1, 1);
    public Vector3 floorScale = new Vector3(1, 1, 1);

    private Cell[,] grid;
    private List<Cell> path; // Path generated by A*

    void Start()
    {
        GenerateMaze();
    }

    void GenerateMaze()
    {
        InitializeGrid();
        CreateOuterWalls();
        CreateAllWalls();
        path = GeneratePathAStar(grid[0, 0], grid[width - 1, height - 1]); // A* path
        CarveMazePath();
        CreateEntranceAndExit();
    }

    void InitializeGrid()
    {
        grid = new Cell[width, height];
        for (int x = 0; x < width; x++)
        {
            for (int y = 0; y < height; y++)
            {
                grid[x, y] = new Cell(x, y);

                // Instantiate floor
                Vector3 floorPosition = new Vector3(x, 0, y);
                Instantiate(floorPrefab, floorPosition, Quaternion.identity).transform.localScale = floorScale;
            }
        }
    }

    void CreateOuterWalls()
    {
        // Top and Bottom Walls
        for (int x = -1; x <= width; x++)
        {
            Vector3 topWallPos = new Vector3(x, 0.5f, height);
            Vector3 bottomWallPos = new Vector3(x, 0.5f, -1);
            Instantiate(wallPrefab, topWallPos, Quaternion.identity).transform.localScale = wallScale;
            Instantiate(wallPrefab, bottomWallPos, Quaternion.identity).transform.localScale = wallScale;
        }

        // Left and Right Walls
        for (int y = 0; y < height; y++)
        {
            Vector3 leftWallPos = new Vector3(-1, 0.5f, y);
            Vector3 rightWallPos = new Vector3(width, 0.5f, y);
            Instantiate(wallPrefab, leftWallPos, Quaternion.Euler(0, 90, 0)).transform.localScale = wallScale;
            Instantiate(wallPrefab, rightWallPos, Quaternion.Euler(0, 90, 0)).transform.localScale = wallScale;
        }
    }

    void CreateAllWalls()
    {
        for (int x = 0; x < width; x++)
        {
            for (int y = 0; y < height; y++)
            {
                if (x < width - 1) CreateWall(new Vector3(x + 0.5f, 0.5f, y), Quaternion.Euler(0, 90, 0));
                if (y < height - 1) CreateWall(new Vector3(x, 0.5f, y + 0.5f), Quaternion.identity);
            }
        }
    }

    void CreateWall(Vector3 position, Quaternion rotation)
    {
        Instantiate(wallPrefab, position, rotation).transform.localScale = wallScale;
    }

    List<Cell> GeneratePathAStar(Cell start, Cell goal)
    {
        var openList = new List<Cell> { start };
        var closedList = new HashSet<Cell>();

        while (openList.Count > 0)
        {
            openList.Sort((a, b) => a.FCost.CompareTo(b.FCost));
            var current = openList[0];

            if (current == goal)
            {
                return RetracePath(start, goal);
            }

            openList.Remove(current);
            closedList.Add(current);

            foreach (var neighbor in GetNeighbors(current))
            {
                if (closedList.Contains(neighbor)) continue;

                int newCostToNeighbor = current.GCost + GetDistance(current, neighbor);
                if (newCostToNeighbor < neighbor.GCost || !openList.Contains(neighbor))
                {
                    neighbor.GCost = newCostToNeighbor;
                    neighbor.HCost = GetDistance(neighbor, goal);
                    neighbor.Parent = current;

                    if (!openList.Contains(neighbor))
                        openList.Add(neighbor);
                }
            }
        }
        return new List<Cell>(); // No path found
    }

    void CarveMazePath()
    {
        foreach (var cell in path)
        {
            if (cell.Parent != null)
            {
                RemoveWall(cell, cell.Parent);
            }
        }
    }

    List<Cell> RetracePath(Cell start, Cell end)
    {
        var path = new List<Cell>();
        Cell current = end;

        while (current != start)
        {
            path.Add(current);
            current = current.Parent;
        }
        path.Reverse();
        return path;
    }

    List<Cell> GetNeighbors(Cell cell)
    {
        var neighbors = new List<Cell>();

        if (cell.X > 0) neighbors.Add(grid[cell.X - 1, cell.Y]);
        if (cell.X < width - 1) neighbors.Add(grid[cell.X + 1, cell.Y]);
        if (cell.Y > 0) neighbors.Add(grid[cell.X, cell.Y - 1]);
        if (cell.Y < height - 1) neighbors.Add(grid[cell.X, cell.Y + 1]);

        return neighbors;
    }

    int GetDistance(Cell a, Cell b)
    {
        int distX = Mathf.Abs(a.X - b.X);
        int distY = Mathf.Abs(a.Y - b.Y);
        return distX + distY;
    }

    void RemoveWall(Cell current, Cell next)
    {
        Vector3 wallPosition = Vector3.zero;
        Quaternion wallRotation = Quaternion.identity;

        if (current.X == next.X)
        {
            wallPosition = new Vector3(current.X, 0.5f, (current.Y + next.Y) / 2f);
        }
        else if (current.Y == next.Y)
        {
            wallPosition = new Vector3((current.X + next.X) / 2f, 0.5f, current.Y);
            wallRotation = Quaternion.Euler(0, 90, 0);
        }

        Collider[] colliders = Physics.OverlapBox(wallPosition, new Vector3(0.5f, 0.5f, 0.1f), wallRotation);
        foreach (var collider in colliders)
        {
            if (collider.gameObject.CompareTag("Wall"))
            {
                Destroy(collider.gameObject);
            }
        }
    }

    void CreateEntranceAndExit()
    {
        // Create entrance at (0, 0) and exit at (width - 1, height - 1)
        RemoveWall(grid[0, 0], grid[0, 1]);  // Entrance
        RemoveWall(grid[width - 1, height - 2], grid[width - 1, height - 1]); // Exit
    }

    private class Cell
    {
        public int X;
        public int Y;
        public int GCost;
        public int HCost;
        public int FCost => GCost + HCost;
        public Cell Parent;
        public bool IsVisited;

        public Cell(int x, int y)
        {
            X = x;
            Y = y;
            GCost = int.MaxValue;
            HCost = 0;
            Parent = null;
            IsVisited = false;
        }
    }
}
